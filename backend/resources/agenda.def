AGENDA
    HAS-GOAL    GOAL; multiple, unordered

GOAL isa VARMAP
    NAME        Str; singleton
    STATUS      Literal("pending" or "active" or "satisfied" or "abandoned")
    PRIORITY    Literal(Numeric) or CALCULATE-STATEMENT; singleton
    PLAN        [ACTION]; multiple, ordered
    WHEN        [CONDITION]; multiple, ordered
    _PRIORITY   Literal(Numeric); singleton, cached result of evaluating PRIORITY

ACTION
    NAME        Str; singleton; optional
    SELECT      Literal(DEFAULT) or BOOLEAN-STATEMENT; singleton
    PERFORM     [STATEMENT or Literal(NULL)]; multiple, ordered

CONDITION
    IF          [BOOLEAN-STATEMENT]; multiple, unordered
    LOGIC       Literal("and" or "or" or "nor" or "nand" or "not"); singleton, default = "and"; "not" is the same as "nor"
    STATUS      Literal("pending" or "active" or "satisfied" or "abandoned")

VARMAP
    WITH        [Literal(Str)]; multiple, ordered (params from instantiation are mapped in order here)
    _WITH       [VARIABLE]; multiple, unordered, not declared by knowledge (this is internal bookkeeping to help map names to instances of variables)

VARIABLE
    FROM        VARMAP; singleton (instance of the goal)
    NAME        Literal(Str); singleton (the name of the variable in the varmap)
    VALUE       Identifier or Literal; singleton

STATEMENT (hierarchy)
    RETURNING-STATEMENT
        BOOLEAN-STATEMENT
            EXISTS-STATEMENT
            IS-STATEMENT
        MAKEINSTANCE-STATEMENT
        QUERY-STATEMENT
        SLOT-STATEMENT
        MP-STATEMENT
    NONRETURNING-STATEMENT
        FOREACH-STATEMENT
        ADDFILLER-STATEMENT
        ASSIGNFILLER-STATEMENT

MAKEINSTANCE-STATEMENT
    OF          Identifier; singleton
    PARAMS      [Identifier or Literal]; multiple, ordered

ADDFILLER-STATEMENT
    TO          Identifier or QUERY; singleton
    SLOT        Str; singleton
    ADD         Identifier or Literal; singleton

ASSIGNFILLER-STATEMENT
    TO          Identifier or QUERY; singleton
    SLOT        Str; singleton
    ASSIGN      Identifier or Literal; singleton

QUERY-STATEMENT
    FIND        Literal(Query); singleton

FOREACH-STATEMENT
    FROM        QUERY; singleton
    ASSIGN      Literal(Str); singleton (the variable to assign the VALUE at each loop into; this will be resolved using _VARMAP)
    DO          [STATEMENT]; multiple, ordered

EXISTS-STATEMENT
    FIND        Literal(Query); singleton

IS-STATEMENT
    DOMAIN      Identifier or Literal(Str) or QUERY; singleton, if QUERY only one match is required for SLOT/FILLER
    SLOT        Literal(Str); singleton
    FILLER      Identifier or Literal; singleton

MP-STATEMENT
    CALLS       Str; singleton
    PARAMS      [Identifier or Literal]; multiple, ordered

CALCULATE-STATEMENT
    TBD ////////



---------- Example ----------

FIND-SOMETHING-TO-DO isa GOAL           // With priority 0.1, either acknowledge any input, or just idle
  NAME value "Find Something to Do"
  PRIORITY value Literal(0.1)
  PLAN value ACTION-1
  PLAN value ACTION-2

ACTION-1 isa ACTION                     // Acknowledge input if any exists (TMRs where status=pending)
  NAME value "Acknowledge Input"
  SELECT value EXISTS-1
  PERFORM value FOREACH-1

ACTION-2 isa ACTION                     // Do nothing as a default action
  NAME value "Idle"
  SELECT value Literal(DEFAULT)
  PERFORM value Literal(NULL)

EXISTS-1 isa EXISTS-STATEMENT           // Are there any input tmrs whose status is pending?
  FIND value Literal(Query)             // SELF-[HAS-INPUT]->@TMR-INPUT[status=pending]

FOREACH-1 isa FOREACH-STATEMENT         // For each pending tmr, create a goal to understand it.
  FROM value QUERY-1
  ASSIGN value "VAR.FOREACH-1$TMR"      // Each value that is looped through is temporarily assigned to the VALUE of this frame.
  DO value ADDFILLER-1

QUERY-1 isa QUERY-STATEMENT             // Find all input tmrs whose status is pending.
  FIND value Literal(Query)             // SELF-[HAS-INPUT]->@TMR-INPUT[status=pending]

ADDFILLER-1 isa ADDFILLER-STATEMENT     // Add a goal (understand tmr) instance to SELF (using HAS-GOAL).
  TO value Identifier(SELF)
  SLOT value Literal("HAS-GOAL")
  ADD value MAKEINSTANCE-1

MAKEINSTANCE-1 isa MAKEINSTANCE-STATEMENT   // Make a new instance of the goal UNDERSTAND-TMR, and use the looped variable as an input parameter.
  OF value UNDERSTAND-TMR
  PARAM value ["VAR.FOREACH-1$TMR"]

UNDERSTAND-TMR isa GOAL                 // With priority 0.9, understand the input (using a meaning procedure).
  NAME value "Understand TMR"
  VARIABLE value ["VAR.UNDERSTAND-TMR$TMR"]   // The first input parameter is mapped to the VALUE of this frame.
  PRIORITY value Literal(0.9)
  CONDITION value CONDITION-1
  PLAN value ACTION-3

CONDITION-1                             // When the input has been understood, the goal is satisfied
  IF value IS-1
  STATUS value Literal("satisfied")

IS-1 isa IS-STATEMENT                   // Is the TMR marked as understood (STATUS = "understood")?
  DOMAIN value "VAR.UNDERSTAND-TMR$TMR"
  SLOT value Literal("STATUS")
  FILLER value "understood"

ACTION-3                                // Trigger the understanding MP, and then mark the TMR as "understood" (rather than "pending")
  NAME value "Understand"
  SELECT value Literal(DEFAULT)
  PERFORM value [MP-1, ASSIGNFILLER-1]

MP-1 isa MP-STATEMENT                   // Run a registered MP for understanding a TMR
  CALLS value "understand-tmr"          // Some existing MP
  PARAMS ["VAR.UNDERSTAND-TMR$TMR"]       // The TMR to pass into the MP (which it is expecting)

ASSIGNFILLER-1 isa ASSIGNFILLER-STATEMENT   // Mark the TMR as "understood"
  TO value "VAR.UNDERSTAND-TMR$TMR"         // Note that when referring to a variable (other than assigning it at GOAL level), you are referring to its resolved VALUE
  SLOT value Literal("STATUS")
  ASSIGN value Literal("understood")



---------- Control Flow Notes ----------

The only thing that is ever instanced are the GOALs and associated VARIABLEs.  All of the actions, statements, etc. are
just inherited as-is, and not instanced.  A new instance of a GOAL looks through all of its VARIABLE fillers, and for
each name (they are just strings), it creates a new instance of a VARIABLE, pointing to itself (the FROM field), assigning
the NAME, and then assigning a VALUE if an input parameter was provided (at that index).  Finally, the GOAL instance
adds a pointer to that VARIABLE onto its _VARMAP internal property.  As long as a reference to the GOAL instance is
available at all stages of processing (which it will be), then any variable by name can be resolved, and those names
are only unique in the scope of any goal instance.

Anything internal can then read the GOAL instances variables, as well as write to them.
Anything internal can *create* new GOAL instance variables as well, simply by referring to a variable by a new name.  The
internal machinations will need to follow the same procedure (creating a new VARIABLE, assigning a name, assigning the
goal instance, and possibly assigning the value) - at which point it can be accessed by anything in the usual way.  An
example of this is the FOREACH-STATEMENT, which creates and then reuses a VARIABLE that is accessible by anything inside
its own loop (although technically then accessible afterwards as well, as it is not removed, making the last value
available for whatever reasons could be dreamed up).

Whenever a Literal(Str) that is a variable is encountered in any capacity that is not explicitly handled, it should .resolve() into
the VALUE by accessing the GOAL instance, finding the _VARMAP, finding the associated VARIABLE (by NAME), accessing
the VALUE, and then resolving that (resulting in either a Frame or a Literal).  (This may mean that Variables need to
be rolled into the default functionality, but perhaps they can be put into an overridden Filler type for agenda processing).